input {
    jdbc {
        jdbc_connection_string => "${SPRING_DATASOURCE_URL}"
        jdbc_user => "${SPRING_DATASOURCE_USERNAME}"
        jdbc_password => "${SPRING_DATASOURCE_PASSWORD}"
        jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/postgresql.jar"
        jdbc_driver_class => "org.postgresql.Driver"
        jdbc_paging_enabled => true
        schedule => "*/10 * * * * *"
        statement => "
                    SELECT
                      c.id,
                      c.evolves_from_id,
                      c.stage,
                      c.name,
                      c.hp,
                      c.attack_skills::text AS attack_skills,
                      c.weakness_type,
                      c.resistance_type,
                      c.retreat_cost,
                      c.game_set,
                      c.pokemon_type,
                      c.regulation_mark,
                      s.id AS pokemon_owner_id,
                      c.card_number
                    FROM pokemon.cards c
                    LEFT JOIN pokemon.students s ON c.pokemon_owner_id = s.id
                "
    }
}

filter {
    json {
        source => "attack_skills"
        target => "attack_skills_parsed"
    }
    mutate {
        rename => { "attack_skills_parsed" => "attack_skills" }
    }

    aggregate {
           task_id => "%{id}"
           code => "
               # If this is the first event for that card_id, create a new map to store it
               if !map['card']
                   map['card'] = {
                       'id' => event.get('id'),
                       'evolves_from_id' => event.get('evolves_from_id'),
                       'stage' => event.get('stage'),
                       'name' => event.get('name'),
                       'hp' => event.get('hp'),
                       'attack_skills' => event.get('attack_skills'),
                       'weakness_type' => event.get('weakness_type'),
                       'resistance_type' => event.get('resistance_type'),
                       'retreat_cost' => event.get('retreat_cost'),
                       'game_set' => event.get('game_set'),
                       'pokemon_type' => event.get('pokemon_type'),
                       'regulation_mark' => event.get('regulation_mark'),
                       'card_number' => event.get('card_number'),
                       'pokemon_owner' => []
                   }
               end

               # If there's a student_id, add it to the students array
               if event.get('pokemon_owner_id')
                   map['card']['pokemon_owner'] << {
                       'id' => event.get('id'),
                       'first_name' => event.get('first_name'),
                       'last_name' => event.get('last_name'),
                       'student_group' => event.get('student_group')
                   }
               end
           "
           push_map_as_event_on_timeout => true
           timeout_task_id_field => "id"
           timeout => 5

       }

       # Drop all intermediate events (which have incomplete data),
       # keep only the final aggregated events with _aggregatetimeout tag
       if !("_aggregatetimeout" in [tags]) {
           drop { }
       }
}

output {
    elasticsearch {
        hosts => "elasticsearch:9200"
        index => "cards"
        document_id => "%{id}"
        user => "logstash_internal"
        password => "${LOGSTASH_INTERNAL_PASSWORD}"
    }
}